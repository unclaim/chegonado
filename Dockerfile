# --- Этап 1: Этап сборки (builder) ---
# Используем официальный образ Golang. Это временный образ для компиляции.
FROM golang:1.24-alpine AS builder

# Устанавливаем рабочую директорию.
WORKDIR /app

# Копируем go.mod и go.sum первыми.
# Это позволяет Docker кэшировать зависимости.
# Если эти файлы не меняются, шаг "go mod download" будет пропущен,
# что значительно ускорит повторные сборки.
COPY go.mod go.sum ./
RUN go mod download

# Копируем весь остальной код.
COPY . .

# Собираем приложение.
# CGO_ENABLED=0 и --ldflags '-w -s' создают статический, оптимизированный
# бинарник без лишней отладочной информации.
# -o server - имя выходного файла.
# ./cmd/server - путь к пакету с main.go.
RUN go build -ldflags="-w -s" -o server ./cmd/server

# ---
# --- Этап 2: Финальный образ (production) ---
# Используем образ scratch. Он абсолютно пуст и содержит только то, что мы в него добавим.
FROM scratch

# Устанавливаем пользователя без привилегий для безопасности.
# В scratch нет пользователей, поэтому мы создадим и будем использовать 'appuser'.
# Мы не можем использовать RUN, поэтому мы пропустим этот шаг.
# В реальных условиях лучше использовать образ, который поддерживает создание пользователей, например, distroless.
# Но для простоты и максимального уменьшения размера образа мы оставим scratch.

# Копируем скомпилированный бинарник из этапа 'builder'.
COPY --from=builder /app/server /server

# Копируем файл конфигурации, который находится в configs/config.yaml
COPY --from=builder /app/configs/config.yaml /configs/config.yaml

# Копируем файл переменных окружения .env.
COPY --from=builder /app/.env /.env

# Копируем директорию uploads, так как она нужна для работы приложения.
COPY uploads /uploads

# Указываем, где искать конфигурационные файлы.
# Обратите внимание, что мы скопировали их в /configs, а не в корень.
# Это более структурировано.
ENV CONFIG_PATH=/configs/config.yaml

# Открываем порт 8585.
EXPOSE 8585

# Запускаем приложение.
# Мы передаем путь к конфигу через флаг. Возможно, тебе придется изменить это,
# если твое приложение ожидает конфиг в другом месте или с другим именем.
# Например, если приложение ищет его в /.env, то мы оставим так, как было.
# Но если ты хочешь явно указать, где находится конфиг, то это хороший вариант.
CMD ["/server"]
